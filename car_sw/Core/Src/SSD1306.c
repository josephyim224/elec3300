/*
 * SSD1306.c
 *
 *  Created on: Apr 3, 2021
 *      Author: joseph
 *
 *  Code referenced from
 *  https://github.com/adafruit/Adafruit_SSD1306/blob/master/Adafruit_SSD1306.cpp
 *  https://github.com/adafruit/Adafruit-GFX-Library/blob/master/Adafruit_GFX.cpp
 */

#include <stdlib.h>
#include <string.h>

#include "SSD1306.h"

// SOME DEFINES AND STATIC VARIABLES USED INTERNALLY -----------------------
#define ssd1306_swap(a, b)                                                     \
  (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

// LOW-LEVEL UTILS ---------------------------------------------------------

// Issue single command to SSD1306, using I2C or hard/soft SPI as needed.F
// Because command calls are often grouped, SPI transaction and selection
// must be started/ended in calling function for efficiency.
// This is a private function, not exposed (see ssd1306_command() instead).
void ssd1306_command1(uint8_t c) {
	uint8_t data[] = { (uint8_t) 0x00, c };
	HAL_I2C_Master_Transmit(ssd1306.SSD1306_hi2c, ssd1306.i2caddr, data, 2,
			1000);
}

// Issue list of commands to SSD1306, same rules as above re: transactions.
// This is a private function, not exposed.
void ssd1306_commandList(const uint8_t *c, uint8_t n) {
	uint8_t data[n + 1];
	data[0] = (uint8_t) 0x00;
	for (int i = 0; i < n; ++i)
		data[i + 1] = c[i];

	HAL_I2C_Master_Transmit(ssd1306.SSD1306_hi2c, ssd1306.i2caddr, data, n + 1,
			1000);
}

// A public version of ssd1306_command1(), for existing user code that
// might rely on that function. This encapsulates the command transfer
// in a transaction start/end, similar to old library's handling of it.
/*!
 @brief  Issue a single low-level command directly to the SSD1306
 display, bypassing the library.
 @param  c
 Command to issue (0x00 to 0xFF, see datasheet).
 @return None (void).
 */
void ssd1306_command(uint8_t c) {
	ssd1306_command1(c);
}

// REFRESH DISPLAY ---------------------------------------------------------

/*!
 @brief  Push data currently in RAM to SSD1306 display.
 @return None (void).
 @note   Drawing operations are not visible until this function is
 called. Call after each graphics command, or after a whole set
 of graphics commands, as best needed by one's own application.
 */
void display(void) {
	const uint8_t dlist1[] = {
	SSD1306_PAGEADDR, 0,                      // Page start address
			0xFF,               // Page end (not really, but works here)
			SSD1306_COLUMNADDR, 0 }; // Column start address
	ssd1306_commandList(dlist1, sizeof(dlist1));
	ssd1306_command1(SSD1306_WIDTH - 1); // Column end address

	uint16_t count = SSD1306_WIDTH * ((SSD1306_HEIGHT + 7) / 8);
	uint8_t data[count + 1];
	data[0] = (uint8_t) 0x40;
	for (int i = 0; i < count; ++i)
		data[i + 1] = ssd1306.buffer[i];

	HAL_I2C_Master_Transmit(ssd1306.SSD1306_hi2c, ssd1306.i2caddr, data,
			count + 1, 1000);
}

// ALLOCATE & INIT DISPLAY -------------------------------------------------

/*!
 @brief  Allocate RAM for image buffer, initialize peripherals and pins.
 @param  vcs
 VCC selection. Pass SSD1306_SWITCHCAPVCC to generate the display
 voltage (step up) from the 3.3V source, or SSD1306_EXTERNALVCC
 otherwise. Most situations with Adafruit SSD1306 breakouts will
 want SSD1306_SWITCHCAPVCC.
 @param  addr
 I2C address of corresponding SSD1306 display (or pass 0 to use
 default of 0x3C for 128x32 display, 0x3D for all others).
 SPI displays (hardware or software) do not use addresses, but
 this argument is still required (pass 0 or any value really,
 it will simply be ignored). Default if unspecified is 0.
 @param  reset
 If true, and if the reset pin passed to the constructor is
 valid, a hard reset will be performed before initializing the
 display. If using multiple SSD1306 displays on the same bus, and
 if they all share the same reset pin, you should only pass true
 on the first display being initialized, false on all others,
 else the already-initialized displays would be reset. Default if
 unspecified is true.
 @param  periphBegin
 If true, and if a hardware peripheral is being used (I2C or SPI,
 but not software SPI), call that peripheral's begin() function,
 else (false) it has already been done in one's sketch code.
 Cases where false might be used include multiple displays or
 other devices sharing a common bus, or situations on some
 platforms where a nonstandard begin() function is available
 (e.g. a TwoWire interface on non-default pins, as can be done
 on the ESP8266 and perhaps others).
 @return true on successful allocation/init, false otherwise.
 Well-behaved code should check the return value before
 proceeding.
 @note   MUST call this function before any drawing or updates!
 */
uint8_t ssd1306_begin(I2C_HandleTypeDef *SSD1306_hi2c) {
	ssd1306.SSD1306_hi2c = SSD1306_hi2c;

	// If I2C address is unspecified, use default
	// (0x3C for 32-pixel-tall displays, 0x3D for all others).
	ssd1306.i2caddr = 0x3C << 1;
	ssd1306.vccstate = SSD1306_SWITCHCAPVCC;
	ssd1306.rotation = 0;
	ssd1306.buffer = (uint8_t*) malloc(
	SSD1306_WIDTH * ((SSD1306_HEIGHT + 7) / 8));

	clearDisplay();

	// Init sequence
	const uint8_t init1[] = { SSD1306_DISPLAYOFF,	// 0xAE
			SSD1306_SETDISPLAYCLOCKDIV,				// 0xD5
			0x80,							// the suggested ratio 0x80
			SSD1306_SETMULTIPLEX }; 				// 0xA8
	ssd1306_commandList(init1, sizeof(init1));
	ssd1306_command1(SSD1306_HEIGHT - 1);

	const uint8_t init2[] = { SSD1306_SETDISPLAYOFFSET,	// 0xD3
			0x0, 										// no offset
			SSD1306_SETSTARTLINE | 0x0, 				// line #0
			SSD1306_CHARGEPUMP };        				// 0x8D
	ssd1306_commandList(init2, sizeof(init2));

	ssd1306_command1((ssd1306.vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0x14);

	const uint8_t init3[] = { SSD1306_MEMORYMODE,	// 0x20
			0x00, 								// 0x0 act like ks0108
			SSD1306_SEGREMAP | 0x1,
			SSD1306_COMSCANDEC };
	ssd1306_commandList(init3, sizeof(init3));

	uint8_t comPins = 0x02;
	uint8_t contrast = 0x8F;

	ssd1306_command1(SSD1306_SETCOMPINS);
	ssd1306_command1(comPins);
	ssd1306_command1(SSD1306_SETCONTRAST);
	ssd1306_command1(contrast);

	ssd1306_command1(SSD1306_SETPRECHARGE); 			// 0xd9
	ssd1306_command1((ssd1306.vccstate == SSD1306_EXTERNALVCC) ? 0x22 : 0xF1);
	const uint8_t init5[] = { SSD1306_SETVCOMDETECT, 	// 0xDB
			0x40,
			SSD1306_DISPLAYALLON_RESUME, 				// 0xA4
			SSD1306_NORMALDISPLAY, 						// 0xA6
			SSD1306_DEACTIVATE_SCROLL,
			SSD1306_DISPLAYON }; 				// Main screen turn on
	ssd1306_commandList(init5, sizeof(init5));

	return true;
}

// DRAWING FUNCTIONS -------------------------------------------------------

/*!
 @brief  Set/clear/invert a single pixel. This is also invoked by the
 Adafruit_GFX library in generating many higher-level graphics
 primitives.
 @param  x
 Column of display -- 0 at left to (screen width - 1) at right.
 @param  y
 Row of display -- 0 at top to (screen height -1) at bottom.
 @param  color
 Pixel color, one of: SSD1306_BLACK, SSD1306_WHITE or SSD1306_INVERT.
 @return None (void).
 @note   Changes buffer contents only, no immediate effect on display.
 Follow up with a call to display(), or with other graphics
 commands as needed by one's own application.
 */
void drawPixel(int16_t x, int16_t y, uint16_t color) {
	if ((x >= 0) && (x < SSD1306_WIDTH) && (y >= 0) && (y < SSD1306_HEIGHT)) {
		// Pixel is in-bounds. Rotate coordinates if needed.
		switch (ssd1306.rotation) {
		case 1:
			ssd1306_swap(x, y);
			x = SSD1306_WIDTH - x - 1;
			break;
		case 2:
			x = SSD1306_WIDTH - x - 1;
			y = SSD1306_HEIGHT - y - 1;
			break;
		case 3:
			ssd1306_swap(x, y);
			y = SSD1306_HEIGHT - y - 1;
			break;
		}
		switch (color) {
		case SSD1306_WHITE:
			ssd1306.buffer[x + (y / 8) * SSD1306_WIDTH] |= (1 << (y & 7));
			break;
		case SSD1306_BLACK:
			ssd1306.buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y & 7));
			break;
		case SSD1306_INVERSE:
			ssd1306.buffer[x + (y / 8) * SSD1306_WIDTH] ^= (1 << (y & 7));
			break;
		}
	}
}

/*!
 @brief  Clear contents of display buffer (set all pixels to off).
 @return None (void).
 @note   Changes buffer contents only, no immediate effect on display.
 Follow up with a call to display(), or with other graphics
 commands as needed by one's own application.
 */
void clearDisplay(void) {
	memset(ssd1306.buffer, 0, SSD1306_WIDTH * ((SSD1306_HEIGHT + 7) / 8));
}

/*!
 @brief  Draw a horizontal line. This is also invoked by the Adafruit_GFX
 library in generating many higher-level graphics primitives.
 @param  x
 Leftmost column -- 0 at left to (screen width - 1) at right.
 @param  y
 Row of display -- 0 at top to (screen height -1) at bottom.
 @param  w
 Width of line, in pixels.
 @param  color
 Line color, one of: SSD1306_BLACK, SSD1306_WHITE or SSD1306_INVERT.
 @return None (void).
 @note   Changes buffer contents only, no immediate effect on display.
 Follow up with a call to display(), or with other graphics
 commands as needed by one's own application.
 */
void drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
	uint8_t bSwap = false;
	switch (ssd1306.rotation) {
	case 1:
		// 90 degree rotation, swap x & y for rotation, then invert x
		bSwap = true;
		ssd1306_swap(x, y);
		x = SSD1306_WIDTH - x - 1;
		break;
	case 2:
		// 180 degree rotation, invert x and y, then shift y around for height.
		x = SSD1306_WIDTH - x - 1;
		y = SSD1306_HEIGHT - y - 1;
		x -= (w - 1);
		break;
	case 3:
		// 270 degree rotation, swap x & y for rotation,
		// then invert y and adjust y for w (not to become h)
		bSwap = true;
		ssd1306_swap(x, y);
		y = SSD1306_HEIGHT - y - 1;
		y -= (w - 1);
		break;
	}

	if (bSwap)
		drawFastVLineInternal(x, y, w, color);
	else
		drawFastHLineInternal(x, y, w, color);
}

void drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {

	if ((y >= 0) && (y < SSD1306_HEIGHT)) { // Y coord in bounds?
		if (x < 0) {                  // Clip left
			w += x;
			x = 0;
		}
		if ((x + w) > SSD1306_WIDTH) { // Clip right
			w = (SSD1306_WIDTH - x);
		}
		if (w > 0) { // Proceed only if width is positive
			uint8_t *pBuf = &ssd1306.buffer[(y / 8) * SSD1306_WIDTH + x], mask =
					1 << (y & 7);
			switch (color) {
			case SSD1306_WHITE:
				while (w--) {
					*pBuf++ |= mask;
				}
				;
				break;
			case SSD1306_BLACK:
				mask = ~mask;
				while (w--) {
					*pBuf++ &= mask;
				}
				;
				break;
			case SSD1306_INVERSE:
				while (w--) {
					*pBuf++ ^= mask;
				}
				;
				break;
			}
		}
	}
}

/*!
 @brief  Draw a vertical line. This is also invoked by the Adafruit_GFX
 library in generating many higher-level graphics primitives.
 @param  x
 Column of display -- 0 at left to (screen width -1) at right.
 @param  y
 Topmost row -- 0 at top to (screen height - 1) at bottom.
 @param  h
 Height of line, in pixels.
 @param  color
 Line color, one of: SSD1306_BLACK, SSD1306_WHITE or SSD1306_INVERT.
 @return None (void).
 @note   Changes buffer contents only, no immediate effect on display.
 Follow up with a call to display(), or with other graphics
 commands as needed by one's own application.
 */
void drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
	uint8_t bSwap = false;
	switch (ssd1306.rotation) {
	case 1:
		// 90 degree rotation, swap x & y for rotation,
		// then invert x and adjust x for h (now to become w)
		bSwap = true;
		ssd1306_swap(x, y);
		x = SSD1306_WIDTH - x - 1;
		x -= (h - 1);
		break;
	case 2:
		// 180 degree rotation, invert x and y, then shift y around for height.
		x = SSD1306_WIDTH - x - 1;
		y = SSD1306_HEIGHT - y - 1;
		y -= (h - 1);
		break;
	case 3:
		// 270 degree rotation, swap x & y for rotation, then invert y
		bSwap = true;
		ssd1306_swap(x, y);
		y = SSD1306_HEIGHT - y - 1;
		break;
	}

	if (bSwap)
		drawFastHLineInternal(x, y, h, color);
	else
		drawFastVLineInternal(x, y, h, color);
}

void drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

	if ((x >= 0) && (x < SSD1306_WIDTH)) { // X coord in bounds?
		if (__y < 0) {               // Clip top
			__h += __y;
			__y = 0;
		}
		if ((__y + __h) > SSD1306_HEIGHT) { // Clip bottom
			__h = (SSD1306_HEIGHT - __y);
		}
		if (__h > 0) { // Proceed only if height is now positive
			// this display doesn't need ints for coordinates,
			// use local byte registers for faster juggling
			uint8_t y = __y, h = __h;
			uint8_t *pBuf = &ssd1306.buffer[(y / 8) * SSD1306_WIDTH + x];

			// do the first partial byte, if necessary - this requires some masking
			uint8_t mod = (y & 7);
			if (mod) {
				// mask off the high n bits we want to set
				mod = 8 - mod;
				// note - lookup table results in a nearly 10% performance
				// improvement in fill* functions
				// uint8_t mask = ~(0xFF >> mod);
				const uint8_t premask[8] = { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8,
						0xFC, 0xFE };
				uint8_t mask = premask[mod]; // adjust the mask if we're not going to reach the end of this byte
				if (h < mod)
					mask &= (0XFF >> (mod - h));

				switch (color) {
				case SSD1306_WHITE:
					*pBuf |= mask;
					break;
				case SSD1306_BLACK:
					*pBuf &= ~mask;
					break;
				case SSD1306_INVERSE:
					*pBuf ^= mask;
					break;
				}
				pBuf += SSD1306_WIDTH;
			}

			if (h >= mod) { // More to go?
				h -= mod;
				// Write solid bytes while we can - effectively 8 rows at a time
				if (h >= 8) {
					if (color == SSD1306_INVERSE) {
						// separate copy of the code so we don't impact performance of
						// black/white write version with an extra comparison per loop
						do {
							*pBuf ^= 0xFF; // Invert byte
							pBuf += SSD1306_WIDTH; // Advance pointer 8 rows
							h -= 8;       // Subtract 8 rows from height
						} while (h >= 8);
					} else {
						// store a local value to work with
						uint8_t val = (color != SSD1306_BLACK) ? 255 : 0;
						do {
							*pBuf = val;   // Set byte
							pBuf += SSD1306_WIDTH; // Advance pointer 8 rows
							h -= 8;       // Subtract 8 rows from height
						} while (h >= 8);
					}
				}

				if (h) { // Do the final partial byte, if necessary
					mod = h & 7;
					// this time we want to mask the low bits of the byte,
					// vs the high bits we did above
					// uint8_t mask = (1 << mod) - 1;
					// note - lookup table results in a nearly 10% performance
					// improvement in fill* functions
					const uint8_t postmask[8] = { 0x00, 0x01, 0x03, 0x07, 0x0F,
							0x1F, 0x3F, 0x7F };
					uint8_t mask = postmask[mod];
					switch (color) {
					case SSD1306_WHITE:
						*pBuf |= mask;
						break;
					case SSD1306_BLACK:
						*pBuf &= ~mask;
						break;
					case SSD1306_INVERSE:
						*pBuf ^= mask;
						break;
					}
				}
			}
		} // endif positive height
	}   // endif x in bounds
}

// OTHER HARDWARE SETTINGS -------------------------------------------------

/*!
 @brief  Enable or disable display invert mode (white-on-black vs
 black-on-white).
 @param  i
 If true, switch to invert mode (black-on-white), else normal
 mode (white-on-black).
 @return None (void).
 @note   This has an immediate effect on the display, no need to call the
 display() function -- buffer contents are not changed, rather a
 different pixel mode of the display hardware is used. When
 enabled, drawing SSD1306_BLACK (value 0) pixels will actually draw
 white, SSD1306_WHITE (value 1) will draw black.
 */
void invertDisplay(uint8_t i) {
	ssd1306_command1(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
}

const uint8_t font[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x5B, 0x4F, 0x5B,
		0x3E, 0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x18,
		0x3C, 0x7E, 0x3C, 0x18, 0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x1C, 0x5E, 0x7F,
		0x5E, 0x1C, 0x00, 0x18, 0x3C, 0x18, 0x00, 0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
		0x00, 0x18, 0x24, 0x18, 0x00, 0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x30, 0x48,
		0x3A, 0x06, 0x0E, 0x26, 0x29, 0x79, 0x29, 0x26, 0x40, 0x7F, 0x05, 0x05,
		0x07, 0x40, 0x7F, 0x05, 0x25, 0x3F, 0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x7F,
		0x3E, 0x1C, 0x1C, 0x08, 0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x14, 0x22, 0x7F,
		0x22, 0x14, 0x5F, 0x5F, 0x00, 0x5F, 0x5F, 0x06, 0x09, 0x7F, 0x01, 0x7F,
		0x00, 0x66, 0x89, 0x95, 0x6A, 0x60, 0x60, 0x60, 0x60, 0x60, 0x94, 0xA2,
		0xFF, 0xA2, 0x94, 0x08, 0x04, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x20,
		0x10, 0x08, 0x08, 0x2A, 0x1C, 0x08, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x1E,
		0x10, 0x10, 0x10, 0x10, 0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x30, 0x38, 0x3E,
		0x38, 0x30, 0x06, 0x0E, 0x3E, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x14, 0x7F,
		0x14, 0x7F, 0x14, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x23, 0x13, 0x08, 0x64,
		0x62, 0x36, 0x49, 0x56, 0x20, 0x50, 0x00, 0x08, 0x07, 0x03, 0x00, 0x00,
		0x1C, 0x22, 0x41, 0x00, 0x00, 0x41, 0x22, 0x1C, 0x00, 0x2A, 0x1C, 0x7F,
		0x1C, 0x2A, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x80, 0x70, 0x30, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x20, 0x10,
		0x08, 0x04, 0x02, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x42, 0x7F, 0x40,
		0x00, 0x72, 0x49, 0x49, 0x49, 0x46, 0x21, 0x41, 0x49, 0x4D, 0x33, 0x18,
		0x14, 0x12, 0x7F, 0x10, 0x27, 0x45, 0x45, 0x45, 0x39, 0x3C, 0x4A, 0x49,
		0x49, 0x31, 0x41, 0x21, 0x11, 0x09, 0x07, 0x36, 0x49, 0x49, 0x49, 0x36,
		0x46, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x40,
		0x34, 0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x41, 0x14, 0x14, 0x14, 0x14,
		0x14, 0x00, 0x41, 0x22, 0x14, 0x08, 0x02, 0x01, 0x59, 0x09, 0x06, 0x3E,
		0x41, 0x5D, 0x59, 0x4E, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x7F, 0x49, 0x49,
		0x49, 0x36, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x7F, 0x41, 0x41, 0x41, 0x3E,
		0x7F, 0x49, 0x49, 0x49, 0x41, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x3E, 0x41,
		0x41, 0x51, 0x73, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x41, 0x7F, 0x41,
		0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x7F,
		0x40, 0x40, 0x40, 0x40, 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x7F, 0x04, 0x08,
		0x10, 0x7F, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x7F, 0x09, 0x09, 0x09, 0x06,
		0x3E, 0x41, 0x51, 0x21, 0x5E, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x26, 0x49,
		0x49, 0x49, 0x32, 0x03, 0x01, 0x7F, 0x01, 0x03, 0x3F, 0x40, 0x40, 0x40,
		0x3F, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x63,
		0x14, 0x08, 0x14, 0x63, 0x03, 0x04, 0x78, 0x04, 0x03, 0x61, 0x59, 0x49,
		0x4D, 0x43, 0x00, 0x7F, 0x41, 0x41, 0x41, 0x02, 0x04, 0x08, 0x10, 0x20,
		0x00, 0x41, 0x41, 0x41, 0x7F, 0x04, 0x02, 0x01, 0x02, 0x04, 0x40, 0x40,
		0x40, 0x40, 0x40, 0x00, 0x03, 0x07, 0x08, 0x00, 0x20, 0x54, 0x54, 0x78,
		0x40, 0x7F, 0x28, 0x44, 0x44, 0x38, 0x38, 0x44, 0x44, 0x44, 0x28, 0x38,
		0x44, 0x44, 0x28, 0x7F, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x08, 0x7E,
		0x09, 0x02, 0x18, 0xA4, 0xA4, 0x9C, 0x78, 0x7F, 0x08, 0x04, 0x04, 0x78,
		0x00, 0x44, 0x7D, 0x40, 0x00, 0x20, 0x40, 0x40, 0x3D, 0x00, 0x7F, 0x10,
		0x28, 0x44, 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x7C, 0x04, 0x78, 0x04,
		0x78, 0x7C, 0x08, 0x04, 0x04, 0x78, 0x38, 0x44, 0x44, 0x44, 0x38, 0xFC,
		0x18, 0x24, 0x24, 0x18, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x7C, 0x08, 0x04,
		0x04, 0x08, 0x48, 0x54, 0x54, 0x54, 0x24, 0x04, 0x04, 0x3F, 0x44, 0x24,
		0x3C, 0x40, 0x40, 0x20, 0x7C, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x3C, 0x40,
		0x30, 0x40, 0x3C, 0x44, 0x28, 0x10, 0x28, 0x44, 0x4C, 0x90, 0x90, 0x90,
		0x7C, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x08, 0x36, 0x41, 0x00, 0x00,
		0x00, 0x77, 0x00, 0x00, 0x00, 0x41, 0x36, 0x08, 0x00, 0x02, 0x01, 0x02,
		0x04, 0x02, 0x3C, 0x26, 0x23, 0x26, 0x3C, 0x1E, 0xA1, 0xA1, 0x61, 0x12,
		0x3A, 0x40, 0x40, 0x20, 0x7A, 0x38, 0x54, 0x54, 0x55, 0x59, 0x21, 0x55,
		0x55, 0x79, 0x41, 0x22, 0x54, 0x54, 0x78,
		0x42, // a-umlaut
		0x21, 0x55, 0x54, 0x78, 0x40, 0x20, 0x54, 0x55, 0x79, 0x40, 0x0C, 0x1E,
		0x52, 0x72, 0x12, 0x39, 0x55, 0x55, 0x55, 0x59, 0x39, 0x54, 0x54, 0x54,
		0x59, 0x39, 0x55, 0x54, 0x54, 0x58, 0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
		0x02, 0x45, 0x7D, 0x42, 0x00, 0x01, 0x45, 0x7C, 0x40, 0x7D, 0x12, 0x11,
		0x12,
		0x7D, // A-umlaut
		0xF0, 0x28, 0x25, 0x28, 0xF0, 0x7C, 0x54, 0x55, 0x45, 0x00, 0x20, 0x54,
		0x54, 0x7C, 0x54, 0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x32, 0x49, 0x49, 0x49,
		0x32, 0x3A, 0x44, 0x44, 0x44,
		0x3A, // o-umlaut
		0x32, 0x4A, 0x48, 0x48, 0x30, 0x3A, 0x41, 0x41, 0x21, 0x7A, 0x3A, 0x42,
		0x40, 0x20, 0x78, 0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x3D, 0x42, 0x42, 0x42,
		0x3D, // O-umlaut
		0x3D, 0x40, 0x40, 0x40, 0x3D, 0x3C, 0x24, 0xFF, 0x24, 0x24, 0x48, 0x7E,
		0x49, 0x43, 0x66, 0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0xFF, 0x09, 0x29, 0xF6,
		0x20, 0xC0, 0x88, 0x7E, 0x09, 0x03, 0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
		0x00, 0x44, 0x7D, 0x41, 0x30, 0x48, 0x48, 0x4A, 0x32, 0x38, 0x40, 0x40,
		0x22, 0x7A, 0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x7D, 0x0D, 0x19, 0x31, 0x7D,
		0x26, 0x29, 0x29, 0x2F, 0x28, 0x26, 0x29, 0x29, 0x29, 0x26, 0x30, 0x48,
		0x4D, 0x40, 0x20, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x38, 0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
		0x00, 0x7B, 0x00, 0x00, 0x08, 0x14, 0x2A, 0x14, 0x22, 0x22, 0x14, 0x2A,
		0x14, 0x08, 0x55, 0x00, 0x55, 0x00,
		0x55, // #176 (25% block) missing in old
			  // code
		0xAA, 0x55, 0xAA, 0x55,
		0xAA,             // 50% block
		0xFF, 0x55, 0xFF, 0x55,
		0xFF,             // 75% block
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x14, 0x14,
		0x14, 0xFF, 0x00, 0x10, 0x10, 0xFF, 0x00, 0xFF, 0x10, 0x10, 0xF0, 0x10,
		0xF0, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x14, 0x14, 0x17,
		0x10, 0x1F, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0x1F, 0x00,
		0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10,
		0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x00, 0x00, 0x00, 0xFF,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
		0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x1F,
		0x10, 0x17, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14, 0x17, 0x10, 0x17,
		0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14,
		0x14, 0x14, 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14, 0x14, 0x17,
		0x14, 0x10, 0x10, 0x1F, 0x10, 0x1F, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x10,
		0x10, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00, 0x00, 0x00,
		0x1F, 0x14, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x00, 0x00, 0xF0, 0x10, 0xF0,
		0x10, 0x10, 0xFF, 0x10, 0xFF, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x10, 0x10,
		0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x38, 0x44, 0x44,
		0x38, 0x44, 0xFC, 0x4A, 0x4A, 0x4A,
		0x34, // sharp-s or beta
		0x7E, 0x02, 0x02, 0x06, 0x06, 0x02, 0x7E, 0x02, 0x7E, 0x02, 0x63, 0x55,
		0x49, 0x41, 0x63, 0x38, 0x44, 0x44, 0x3C, 0x04, 0x40, 0x7E, 0x20, 0x1E,
		0x20, 0x06, 0x02, 0x7E, 0x02, 0x02, 0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x1C,
		0x2A, 0x49, 0x2A, 0x1C, 0x4C, 0x72, 0x01, 0x72, 0x4C, 0x30, 0x4A, 0x4D,
		0x4D, 0x30, 0x30, 0x48, 0x78, 0x48, 0x30, 0xBC, 0x62, 0x5A, 0x46, 0x3D,
		0x3E, 0x49, 0x49, 0x49, 0x00, 0x7E, 0x01, 0x01, 0x01, 0x7E, 0x2A, 0x2A,
		0x2A, 0x2A, 0x2A, 0x44, 0x44, 0x5F, 0x44, 0x44, 0x40, 0x51, 0x4A, 0x44,
		0x40, 0x40, 0x44, 0x4A, 0x51, 0x40, 0x00, 0x00, 0xFF, 0x01, 0x03, 0xE0,
		0x80, 0xFF, 0x00, 0x00, 0x08, 0x08, 0x6B, 0x6B, 0x08, 0x36, 0x12, 0x36,
		0x24, 0x36, 0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00, 0x00, 0x18, 0x18, 0x00,
		0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x40, 0xFF, 0x01, 0x01, 0x00, 0x1F,
		0x01, 0x01, 0x1E, 0x00, 0x19, 0x1D, 0x17, 0x12, 0x00, 0x3C, 0x3C, 0x3C,
		0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 // #255 NBSP
		};

// Draw a character
/**************************************************************************/
/*!
 @brief   Draw a single character
 @param    x   Bottom left corner x coordinate
 @param    y   Bottom left corner y coordinate
 @param    c   The 8-bit font-indexed character (likely ascii)
 @param    color 16-bit 5-6-5 Color to draw chraracter with
 @param    bg 16-bit 5-6-5 Color to fill background with (if same as color,
 no background)
 @param    size_x  Font magnification level in X-axis, 1 is 'original' size
 @param    size_y  Font magnification level in Y-axis, 1 is 'original' size
 */
/**************************************************************************/
void drawChar(int16_t x, int16_t y, uint8_t c, uint16_t color, uint16_t bg) {
	if ((x >= SSD1306_WIDTH) ||              		// Clip right
			(y >= SSD1306_HEIGHT) ||             // Clip bottom
			((x + 6 - 1) < 0) || // Clip left
			((y + 8 - 1) < 0))   // Clip top
		return;

	for (int8_t i = 0; i < 5; i++) { // Char bitmap = 5 columns
		uint8_t line = font[c * 5 + i];
		for (int8_t j = 0; j < 8; j++, line >>= 1) {
			if (line & 1) {
				drawPixel(x + i, y + j, color);
			} else if (bg != color) {
				drawPixel(x + i, y + j, bg);
			}
		}
	}
	if (bg != color) { // If opaque, draw vertical line for last column
		drawFastVLine(x + 5, y, 8, bg);
	}
}

void drawString(int16_t x, int16_t y, uint8_t* c, uint8_t n, uint16_t color, uint16_t bg) {
	for (int i = 0; i < n; ++i) {
		drawChar(x+=6, y, c[i], color, bg);
	}
}
